#include <kipr/wombat.h>

// PID Constants (PLACEHOLDER ATM)
float Kp = 0.2;
float Ki = 0.1;
float Kd = 0.05;

// safety variables
float MaxIntegral = 1000;

// camera variables (PLACEHOLDER ATM)
int greenBucket = 1;    // channel for green bucket
int redBucket = 2;      // channel for red bucket
int blueBucket = 0;     // channel for blue bucket
int greenThreshold = 0; // placeholder threshold
int redThreshold = 0;   // placeholder threshold
int blueThreshold = 0;  // placeholder threshold
int lineThreshold = 2600; // Placeholder

// Sensor port  (PLACEHOLDER ATM) MAY NOT BE NEEDED
int sensor_left_port = 0;
int sensor_right_port = 1;
int sensor_center_port = 2;

// motor speed base
int driveLeftWheel = 120;
int driveRightWheel = 120;

// PID Variables
float error, previous_error = 0, integral = 0, derivative;

void turn();
void drive();
void returnToRectangle();
void findBorder();
void box_distance();
int cameraMatch();

int main()
{
    printf("connecting to create wallaby...\n");
    create_connect();
    printf("connected!");
    printf("connecting camera!");
    camera_open();
    printf("connected!");
    int programState = 0; // used for program progression
    // state 1:: find rectangle border
    while (programState < 1)
    {
        // find the rectangle border and align
        findBorder();
        programState++;
    }
    // begin the wallride
    while (programState < 2)
    {
        cameramatch();
        wallride();
        programState++;
    }
    // find the green box
    while (programState < 3)
    {
        if (get_object_count(greenBucket) > 0)
        {
            box_distance_green();
        }
        if (analog(0) == 0)
        {
            programState++;
        }
    }
    // return to rectangle
    while (programState < 4)
    {
        findBorder();
        cameraMatch();
        wallRide();
        programState++;
    }
    // find the red box
    while (programState < 5)
    {
        if (get_object_count(redBucket) > 0)
        {
            box_distance_red();
        }
        if (analog(0) == 0)
        {
            programState++;
        }
    }
    // return to rectangle
    while (programState < 6)
    {
        findBorder();
        cameraMatch();
        wallRide();
        programState++;
    }
    // find the third box
    while (programState < 7)
    {
        if (get_object_count(blueBucket) > 0)
        {
            box_distance_blue();
        }
        if (analog(0) == 0)
        {
            programState++;
        }
    }
    printf("disconnecting...\n");
    create_stop();
    create_disconnect();
    printf("disconnected!");
    return 0;
}

void drive
{
    create_drive_direct(driveLeftWheel - control, driveRightWheel - control);
}

void turn()
{
    create_drive_direct(driveLeftWheel, -driveRightWheel); // Turns right
}

void findBorder()
{
    // while loop reading when we reach border [mind you example code here]
    while (get_create_lfcliff_amt() < lineThreshold && get_create_rfcliff_amt() < lineThreshold)
    {
        drive();
    }
    // stop when we reach the border
    create_stop();
}

void returnToRectangle()
{
    create_drive_direct(-driveLeftWheel * 2, -driveRightWheel * 2); // goes backwards back into circle
    msleep(1000);                                                   // sleep with drive command to return to rectangle
    create_drive_direct(0, 0);                                      // turn off motors post return
}

void wallRide()
{
    if (cameraMatch != 1)
    { //(cameramatch: if blob is big 0_0

        int time = (seconds() - starttime);
        int lfCliff = get_create_lfcliff_amt();
        int rfCliff = get_create_rfcliff_amt();
        int lCliff = get_create_lcliff_amt();
        int rCliff = get_create_rcliff_amt();
        int error = lfCliff - rfCliff;
        integral += error;
        if (integral > MAX_INTEGRAL)
            integral = MAX_INTEGRAL;
        if (integral < -MAX_INTEGRAL)
            integral = -MAX_INTEGRAL;
        int derivative = error - previousError;
        previousError = error;
        int control = (int)(Kp * error + Ki * integral + Kd * derivative);

        cameraMatch = 0; // reset camera match
    }
}

int cameraMatch(programState)
{
    // basically a function to see if the robot see's a box
    if (programState > 0)
    {
        {
            if (get_object_count(greenBucket) > 0 || get_object_count(redBucket) > 0 || get_object_count(blueBucket);)
            {
                return (1);
            }
        }
    }
}

// function designed to create the 5 feet of distance needed from the box
// red is closest to tape
// blue is furthest from tape
// green is medium from tape

void box_distance_red()
{
    create_stop();           // ensure the machine is stopped
    set_create_total_angle(0);
    while(get_create_total_angle() < 90){
        create_drive(-100, 100); // turn the machine
        msleep(20);
    }

    set_create_distance(304);
    while(get_create_distance() < 1254){
        create_drive(-100, -100);
        msleep(20);
    }

}
void box_distance_blue()
{
    create_stop();           // ensure the machine is stopped
    set_create_total_angle(0);
    while(get_create_total_angle() < 90){
        create_drive(-100, 100); // turn the machine
        msleep(20);
    }

    set_create_distance(1219);
    while(get_create_distance() < 1254){
        create_drive(-100, -100);
        msleep(20);
    }
}

void box_distance_green()
{
    create_stop();           // ensure the machine is stopped
    set_create_total_angle(0);
    while(get_create_total_angle() < 90){
        create_drive(-100, 100); // turn the machine
        msleep(20);
    }

    set_create_distance(914);
    while(get_create_distance() < 1254){
        create_drive(-100, -100);
        msleep(20);
    }
}
